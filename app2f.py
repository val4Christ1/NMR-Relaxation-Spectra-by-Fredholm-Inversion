# -*- coding: utf-8 -*-
"""app_val.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xrhscncP-qygUnbUHeUuqTjrHVARQ-oc
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import lsq_linear, nnls
import streamlit as st
import time

st.set_page_config(layout="wide")

# Sidebar: ranges and steps for time, T1, and T2
st.sidebar.header("Sampling NMR Relaxation Parameters")

# Time points
t_min    = st.sidebar.number_input("Time t min (s)",     min_value=1e-4, value=1e-2, format="%.4f")
t_max    = st.sidebar.number_input("Time t max (s)",     min_value=1e-3, value=10.0,  format="%.2f")
N_t      = st.sidebar.number_input("Number of t points", min_value=100,  value=1500, step=100)

# T1 values
T1_min   = st.sidebar.number_input("T1 min (s)",         min_value=1e-4, value=1e-2, format="%.4f")
T1_max   = st.sidebar.number_input("T1 max (s)",         min_value=1e-3, value=100.0, format="%.1f")
N_T1     = st.sidebar.number_input("Number of T1 values",min_value=10,   value=50,   step=5)

# T2 values
T2_min   = st.sidebar.number_input("T2 min (s)",         min_value=1e-4, value=1e-2, format="%.4f")
T2_max   = st.sidebar.number_input("T2 max (s)",         min_value=1e-3, value=100.0, format="%.1f")
N_T2     = st.sidebar.number_input("Number of T2 values",min_value=10,   value=50,   step=5)

st.sidebar.markdown("---")

# Noise controls
add_noise = st.sidebar.checkbox("Add noise to signal", value=True)
noise_level = st.sidebar.slider("Noise amplitude", 0.0, 0.1, 0.01, 0.001, format="%.3f", 
                                disabled=not add_noise)

# Regularization options
reg_method = st.sidebar.selectbox(
    "Regularization method",
    ["Tikhonov", "Non-negative LS", "Truncated SVD"]
)

reg_param = st.sidebar.slider("Regularization λ", 1e-6, 1e-2, 1e-4, format="%.1e")

# Plot options - Color maps and plot types
st.sidebar.markdown("---")
st.sidebar.header("Plot Options")

# Available colormaps
cmap_options = ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'hsv', 
                'hot', 'cool', 'spring', 'summer', 'autumn', 'winter', 
                'jet', 'rainbow', 'turbo']

# Selectors for each plot
cmap_true = st.sidebar.selectbox("True Distribution Colormap", cmap_options, index=5)
cmap_rec = st.sidebar.selectbox("Reconstructed Distribution Colormap", cmap_options, index=5)
cmap_res = st.sidebar.selectbox("Residual Plot Colormap", cmap_options, index=5)

# Plot type selectors
plot_type_options = ["contourf", "contour"]
plot_type_true = st.sidebar.selectbox("True Distribution Plot Type", plot_type_options, index=0)
plot_type_rec = st.sidebar.selectbox("Reconstructed Distribution Plot Type", plot_type_options, index=0)

# Generate sampling vectors
time_points = np.logspace(np.log10(t_min), np.log10(t_max), int(N_t))
T1_vals     = np.logspace(np.log10(T1_min), np.log10(T1_max), int(N_T1))
T2_vals     = np.logspace(np.log10(T2_min), np.log10(T2_max), int(N_T2))

# Create grids
T1_grid, T2_grid = np.meshgrid(T1_vals, T2_vals, indexing='ij')

# Define kernel and true distribution
def kernel(t, T1, T2):
    return np.exp(-t / T1) * np.exp(-t / T2)

def true_dist(T1, T2):
    return np.exp(-((np.log10(T1) - 0.2)**2 + (np.log10(T2) + 0.5)**2) / 0.1)

# Simulate signal
f_true = true_dist(T1_grid, T2_grid)
S = np.array([np.sum(kernel(t, T1_grid, T2_grid) * f_true) for t in time_points])

# Add noise if enabled
if add_noise:
    S_noisy = S + noise_level * np.random.randn(len(S))
else:
    S_noisy = S

# Inversion methods
def invert_fredholm(S, time_points, T1_grid, T2_grid, method, reg_param):
    Nt = len(time_points)
    nK = T1_grid.size
    K = np.zeros((Nt, nK))
    for i, t in enumerate(time_points):
        K[i, :] = kernel(t, T1_grid, T2_grid).ravel()
    
    if method == "Tikhonov":
        # Tikhonov regularization
        K_reg = np.vstack([K, reg_param * np.eye(nK)])
        S_reg = np.hstack([S, np.zeros(nK)])
        res = lsq_linear(K_reg, S_reg, bounds=(0, np.inf), lsmr_tol='auto', verbose=0)
        return res.x.reshape(T1_grid.shape)
    
    elif method == "Non-negative LS":
        # Standard non-negative least squares
        res = lsq_linear(K, S, bounds=(0, np.inf), lsmr_tol='auto', verbose=0)
        return res.x.reshape(T1_grid.shape)
    
    elif method == "Truncated SVD":
        # Truncated SVD (pseudo-inverse with threshold)
        U, s, Vt = np.linalg.svd(K, full_matrices=False)
        s_inv = np.zeros_like(s)
        threshold = reg_param * np.max(s)
        s_inv[s > threshold] = 1 / s[s > threshold]
        K_inv = Vt.T @ np.diag(s_inv) @ U.T
        f_rec = K_inv @ S
        f_rec[f_rec < 0] = 0  # Apply non-negativity constraint
        return f_rec.reshape(T1_grid.shape)

# Perform inversion with timing
start_time = time.time()
f_rec = invert_fredholm(S_noisy, time_points, T1_grid, T2_grid, reg_method, reg_param)
computation_time = time.time() - start_time

# Calculate error metrics
mse = np.mean((f_rec - f_true)**2)
relative_error = np.linalg.norm(f_rec - f_true) / np.linalg.norm(f_true)

# Calculate marginal distributions
f_true_T1 = np.sum(f_true, axis=1)  # Sum over T2 for each T1
f_true_T2 = np.sum(f_true, axis=0)  # Sum over T1 for each T2
f_rec_T1 = np.sum(f_rec, axis=1)    # Sum over T2 for each T1
f_rec_T2 = np.sum(f_rec, axis=0)    # Sum over T1 for each T2

# Plot
st.title("NMR Relaxation Spectra Tool Using Fredholm Inversion")

# Display computation info
col1, col2, col3 = st.columns(3)
col1.metric("Computation Time", f"{computation_time:.4f} seconds")
col2.metric("MSE", f"{mse:.2e}")
col3.metric("Relative Error", f"{relative_error:.4f}")

# Create figure with subplots
fig = plt.figure(figsize=(20, 12))

# Signal plot
ax1 = plt.subplot(2, 3, 1)
ax1.plot(time_points, S_noisy, '.', label="Measured S(t)", alpha=0.6)
ax1.plot(time_points, S,   '-', label="True S(t)", color='red', linewidth=2)
ax1.set_xscale('log')
ax1.set_xlabel("t (s)")
ax1.set_ylabel("Signal")
ax1.legend()
ax1.set_title("Magnetic Resonance Signal")

# True distribution
ax2 = plt.subplot(2, 3, 2)
if plot_type_true == "contourf":
    cp1 = ax2.contourf(T2_vals, T1_vals, f_true, levels=12, cmap=cmap_true)
else:
    cp1 = ax2.contour(T2_vals, T1_vals, f_true, levels=12, cmap=cmap_true)
ax2.set_xscale('log')
ax2.set_yscale('log')
ax2.set_xlabel("T₂ (s)")
ax2.set_ylabel("T₁ (s)")
ax2.set_title("True f(T₁, T₂)")
plt.colorbar(cp1, ax=ax2)

# Recovered distribution
ax3 = plt.subplot(2, 3, 3)
if plot_type_rec == "contourf":
    cp2 = ax3.contourf(T2_vals, T1_vals, f_rec, levels=12, cmap=cmap_rec)
else:
    cp2 = ax3.contour(T2_vals, T1_vals, f_rec, levels=12, cmap=cmap_rec)
ax3.set_xscale('log')
ax3.set_yscale('log')
ax3.set_xlabel("T₂ (s)")
ax3.set_ylabel("T₁ (s)")
ax3.set_title(f"Reconstructed f(T₁, T₂) - {reg_method}")
plt.colorbar(cp2, ax=ax3)

# Marginal distribution for T1
ax4 = plt.subplot(2, 3, 4)
ax4.semilogx(T1_vals, f_true_T1, 'b-', label="True f(T₁)", linewidth=2)
ax4.semilogx(T1_vals, f_rec_T1, 'r--', label="Reconstructed f(T₁)", linewidth=2)
ax4.set_xlabel("T₁ (s)")
ax4.set_ylabel("f(T₁)")
ax4.legend()
ax4.set_title("Marginal Distribution f(T₁)")
ax4.grid(True, which="both", ls="-", alpha=0.2)

# Marginal distribution for T2
ax5 = plt.subplot(2, 3, 5)
ax5.semilogx(T2_vals, f_true_T2, 'b-', label="True f(T₂)", linewidth=2)
ax5.semilogx(T2_vals, f_rec_T2, 'r--', label="Reconstructed f(T₂)", linewidth=2)
ax5.set_xlabel("T₂ (s)")
ax5.set_ylabel("f(T₂)")
ax5.legend()
ax5.set_title("Marginal Distribution f(T₂)")
ax5.grid(True, which="both", ls="-", alpha=0.2)

# Residual plot
ax6 = plt.subplot(2, 3, 6)
residual = f_rec - f_true
residual_norm = np.abs(residual) / np.max(np.abs(residual))  # Normalized residual
im = ax6.imshow(residual_norm, extent=[np.log10(T2_min), np.log10(T2_max), 
                                       np.log10(T1_max), np.log10(T1_min)], 
                aspect='auto', cmap=cmap_res)
ax6.set_xlabel("log₁₀(T₂)")
ax6.set_ylabel("log₁₀(T₁)")
ax6.set_title("Normalized Residual (|f_rec - f_true|/max)")
plt.colorbar(im, ax=ax6)

plt.tight_layout()
st.pyplot(fig)

# Additional info
st.subheader("Inversion Details")
st.write(f"**Method:** {reg_method}")
st.write(f"**Regularization parameter (λ):** {reg_param:.2e}")
st.write(f"**Noise {'enabled' if add_noise else 'disabled'}:** {noise_level if add_noise else 'N/A'}")